# Numerical Methods

## Introduction

### Computer representation of real numbers

Any positive decimal number $x$ is represented by the ordered coefficents $\{ d_j : j = n, n - 1, \ldots \} \subseteq \{ 0, 1, \ldots, 9 \}$

\begin{equation}
  x = d_n 10^n + d_{n - 1} 10 ^{n - 1} + \cdots + d_1 10 + d_0 + d_{-1} 10^{-1} + \cdots
  (\#eq:decimal)
\end{equation}

For same number $x$, other base $2$ can also be used with binary digits $\{ a_j \} \subseteq \{ 0, 1 \}$

\begin{equation}
  x = a_k 2^k + a_{k - 1} 2 ^{k - 1} + \cdots + a_1 2 + a_0 + a_{-1} 2^{-1} + \cdots
  (\#eq:base2)
\end{equation}

Point between $a_0$ and $a_{-1}$ is called the radix point here.

```{r}
sfsmisc::digitsBase(320, base = 10)
sfsmisc::digitsBase(320, base = 2)
```

See Equations \@ref(eq:decimal) and \@ref(eq:base2). Numbers are expressed with series.

```{example, machineeps, name = "Identical and nearly equal"}
$0.3 - 0.1$ is equal to $0.2$. Can we check this?
```

```{r}
(.3 - .1) == .2
```

It is obviously same, but `R` says it is different. Why?

```{r}
.Machine$double.eps
```

The above number is the smallest positive floating number that the machine can recognize. `all.equal()` function can solve this kind of near-equality problem.

```{r}
all.equal(.2, .3 - .1)
```


## Root-finding in One Dimension

In statistics, it is one of issues to find solutions of

$$f(x) = 0$$

There are various algorithms.

### Bisection method

```{r bisecfig, echo=FALSE, fig.cap="Illustration of bisection method"}
tibble(x = c(0, 2)) %>% 
  ggplot(aes(x = x)) +
  modelr::geom_ref_line(h = 0) +
  stat_function(fun = function(x) {
    (x - 3)^2 - 2
  }) +
  geom_vline(xintercept = c(.5, 1.7), alpha = .5, col = I("grey10")) +
  annotate(
    geom = "point",
    x = -sqrt(2) + 3,
    y = 0,
    col = "red",
    shape = 1
  )
```

Figure \@ref(fig:bisecfig) presents the motivation of bisection method. On both sides of the root, one side of function value is positive and the other side is negative. Thus, if we find any set like this, then we only narrow the two points until finding the solution.

\begin{algorithm}[H] \label{alg:bisection}
  \SetAlgoLined
  \SetKwInOut{Input}{input}
  \SetKwInOut{Output}{output}
  \Input{Equation system $f(x) = 0$, error bound $\epsilon$}
  Initialize two points $x_0$ and $x_1$ such that $$f(x_0) f(x_1) \le 0$$\;
  \If{$f(x_0) f(x_1) < 0$}{
    Change initial values\;
  }
  Set error $e = \lvert x_1 - x_0 \rvert$\;
  \While{$e > \epsilon$}{ \label{alg:bisecwhile}
    Half $$x_2 = \frac{x_0 + x_1}{2}$$\;
    Length of the interval becomes half $e = \frac{e}{2}$\;
    \eIf{$f(x_0) f(x_2) < 0$}{
      Update $x_1 = x_2$\;
    }{
      Update $x_0 = x_2$\;
    }
  }
  \Output{$x = x_2$}
  \caption{Bisection algorithm}
\end{algorithm}

In Line $\ref{alg:bisecwhile}$, we can use condition

$$\lvert f(x_2) \rvert > \epsilon$$

instead, which means that we did not find the root yet.

```{example, bisecexm}
Solve $$a^2 + y^2 + \frac{2ay}{n - 1} = n - 2$$

where $a$ is a specified constant and $n > 2$ is an integer.
```

```{solution}
It can be shown that the analytical solution is

$$y = - \frac{a}{n - 1} \pm \sqrt{n - 2 + a^2 + \Big( \frac{a}{n - 1} \Big)^2}$$
```

```{r}
f_bisec <- function(x, a = .5, n = 20) {
  a^2 + x^2 + 2 * a * x / (n - 1) - (n - 2)
}
#-----------------------------
bisection <- function(x0, x1, fun, eps = .Machine$double.eps^.25, rep_max = 1000, ...) {
  iter <- 0 # stop too many iteration
  if (fun(x0, ...) * fun(x1, ...) > 0) {
    stop(gettextf("both %s and %s should be satisfy the condition", expression(x0), expression(x1)))
  }
  init <- seq(x0, x1, length.out = 3) # x0 x2 x1
  y <- f_bisec(init)
  while (iter < 1000 && abs(y[2]) > eps) {
    iter <- iter + 1
    if (y[1] * y[2] < 0) {
      init[3] <- init[2]
      y[3] <- y[2]
    } else {
      init[1] <- init[2]
      y[1] <- y[2]
    }
    init[2] <- (init[1] + init[3]) / 2
    y[2] <- fun(init[2], ...)
  }
  c(init[2], y[2])
}
```

Using initioal values $x_0 = 0$ and $X_1 = 100$,

```{r}
(bi_exm <- bisection(0, 100, fun = f_bisec, a = .5, n = 20))
```

$x = `r bi_exm[1]`$ has been computed. The following figure shows that this answer is reasonable.

```{r bisecroot, echo=FALSE, fig.cap="Example curve"}
tibble(x = c(0, 10)) %>% 
  ggplot(aes(x = x)) +
  modelr::geom_ref_line(h = 0) +
  stat_function(fun = f_bisec) +
  annotate(
    geom = "point", 
    x = bi_exm[1], 
    y = f_bisec(bi_exm[1]), 
    col = "red", 
    shape = 4,
    size = 3
  )
```

### Brent's method

Brent's method combines the root bracketing and bisection with inverse quadratic interpolation. `uniroot()` uses this method. Refer to Example \@ref(exm:bisecexm).

```{r}
(brent <- 
  uniroot(
    f = f_bisec,
    interval = c(0, 100),
    a = .5,
    n = 20
  ))
```

This method assures convergence of the bisection method. Morover, it is generally faster than bisection.


## Numerical Integration

Try to compute

$$I = \int_a^b f(x) dx$$

### Trapezoidal rule

From definition of Riemann integration, we can compute integration $I$ by partitioning intervals. Areas of rectangles can be considered or trapezoids can also be considered. If we use trapezoids, it will be more closed to the target curve, but the formula might be quite complex. For the length of subintervals $h = \frac{b - a}{n}$,

\begin{equation}
  \frac{h}{2} f(a) + h \sum_{i = 1}^{n - 1} f(x_i) + \frac{h}{2} f(b)
  (\#eq:trape)
\end{equation}

For fun, we use `Rcpp` for trapezoid method. `Rcpp` integrate `R` and `C++`. This accelerate execution speed like loop.

```{r, eval=FALSE}
library(Rcpp)
```

The following code should be written in `cpp` file separately, or in `cppFunction()` as character.

```{Rcpp}
#include <Rcpp.h>
using namespace Rcpp;

// [[Rcpp::export]]
NumericVector trapezoid(Function target, double a, double b, int n) {
  double h = (b - a) / n;
  NumericVector fa = target(a);
  NumericVector fb = target(b);
  NumericVector integral = (fa + fb) / 2;
  double x = a;
  NumericVector fx = target(x);
  
  for(int i = 0; i < n; i++) {
    x += h;
    NumericVector fx = target(x);
    integral += fx;
  }
  
  integral = integral * h;
  
  return(integral);
}
```

Consider standard normal densitiy. Compare

$$P(-1.96 \le Z \le 1.96)$$

```{r}
phi <- function(x) {
  1 / sqrt(2 * pi) * exp(- x^2 / 2)
}
#----------------------------------
tibble(x1 = -1.96, x2 = 1.96) %>% 
  summarise(
    trapezoid = trapezoid(
      phi,
      a = x1,
      b = x2,
      n = 100
    ),
    pnorm = pnorm(x2) - pnorm(x1)
  )
```

### Adaptive quadrature method

`R` provides a function `integrate()`. This implements a method called an *adaptive quadrature method*. Get

$$\int_0^{\infty} \frac{1}{(\cosh y - \rho r)^{n - 1}}dy$$

with $\rho \in (-1, 1)$, $r \in (-1, 1)$, and $n \ge 2$ integer.

```{r}
integrate_exm <- function(y, n, r, rho) {
  (cosh(y) - rho * r)^(1 - n)
}
```

Denote that $\rho$, $r$, and $n$ should be pre-specified. Consider $(0.2, 0.5, 10)$.

```{r}
integrate(
  f = integrate_exm,
  lower = 0,
  upper = Inf,
  n = 10,
  r = .5,
  rho = .2
)
```


## Maximum Likelihood Problems

Maximum likelihood estimator (MLE) is a estimator such that maximizes likelihood function. Given random sample $x_1, \ldots, x_n \iid f(x_i ; \theta)$, likelihood function can be given by

$$L(\theta) = \prod_{i = 1}^n f(x_i)$$

Then MLE $\hat\theta$ is

\begin{equation}
  \hat\theta = \argmax_{\theta \in \Theta} L(\theta)
  (\#eq:mle)
\end{equation}

Denote that it is equivalent to maximizing log-likilihood $l(\theta) := \ln L(\theta)$.

\begin{equation}
  \hat\theta = \argmax_{\theta \in \Theta} l(\theta)
  (\#eq:mle2)
\end{equation}

Either for $L$ or $l$, we can find the critical point by differentiating in a mathematical point of view.

$$
\begin{cases}
  \frac{d}{d \theta} l(\theta) = 0 \\
  \frac{d^2}{d \theta^2} l(\theta) > 0
\end{cases}
$$

Ignoring the second line, try to find root of first dervative. Finding MLE becomes *root-finding of first derivative function* problem. What we need are

1. Likelihood function or log-likelihood function
2. Its derivative

```{example, findmle, name = "Exponential distribution"}
Let $Y_1, Y_2 \iid Exp(\theta)$, i.e.

$$f(y) = \theta e^{-\theta y}, \quad y > 0, \theta > 0$$

Then the likelihood function is

$$L(\theta) = \theta^2 e^{-\theta(y_1 + y_2)}$$

and log-likelihood

$$l(\theta) = 2 \ln \theta - \theta(y_1 + y_2)$$

Find its MLE $\hat\theta$.
```

```{solution}
Note that for $\theta > 0$,

$$\frac{d}{d\theta}l(\theta) = \frac{2}{\theta} - (y_1 + y_2)$$

Hence, we know that the analytical solution is

$$\hat\theta = \frac{2}{y_1 + y_2}$$
```

```{r}
y <- c(.043, .502)
```

Give input as $l$ and $(y_1, y_2) = (`r y`)$. Here we will use `D()` which enables to output analytical derivative function for `expression`. For example,

```{r}
D(expression(2 * log(theta) - theta * (y1 + y2)), name = "theta")
```

Then we can make the following function.

```{r}
find_mle <- function(l, args, name, interval = c(1, 5), ...) {
  differ <- D(substitute(l), name = name)
  args[[name]] <- 0
  differ_fun <- function(x) {
    args[[name]] <- x
    eval(differ, envir = args, enclos = parent.frame())
  }
  uniroot(
    f = differ_fun,
    interval = interval,
    ...
  )$root
}
#-------------------------------------
find_mle(
  2 * log(theta) - theta * (y1 + y2), 
  args = list(y1 = y[1], y2 = y[2]), 
  name = "theta",
  interval = c(1, 5)
)
```

In `stats4` library, there is a function called `mle()`. We can also use this one.

```{r}
exp_logLik <- function(theta = 1) {
  - length(y) * log(theta) + theta * sum(y) # -l(theta)
}
#-----------------------------------
stats4::mle(exp_logLik) %>% 
  stats4::summary()
```

## One-Dimensional Optimization

In the last section, our custom function finding MLE have tried to find root. On the contrary, `stats4::mle()` optimizes given negative log-likelihood, i.e. find its minimum.

```{example, maxlike, name = "Find maximum of univariate function"}
Maximize the function

$$f(x) = \frac{\ln (1 + \ln x)}{\ln(1 + x)}$$

with respect to $x$.
```

```{r logfrac, fig.cap="Function $f$ in Example"}
log_frac <- function(x) {
  log(1 + log(x)) / log(1 + x)
}
#---------------------------
gg_curve(
  log_frac, from = 2, to = 14, 
  ylab = expression(log(1 + log(x)) / log(1 + x))
)
```

`nlm()` finds minimization with a Newton-type algorithm. `optimize()` performs optimization based on various `method`. To find maximum, we should specify `maximum = TRUE`. It is set to be `FALSE` by default and find the minimum.

```{r}
optimize(
  log_frac,
  lower = 2,
  upper = 8,
  maximum = TRUE
)
```

`maximum` is a point where maximum is occurred and `objective` is a maximum value of the function.


## Two-Dimensional Optimization


```{r}
mix_ll <- function(param, y) {
  # mixing probability
  prob <- param[1:2]
  prob <- c(prob, 1 - sum(prob))
  # rate of dgamma
  rate <- param[3:4]
  rate <- c(rate, 1 - sum(rate)) # constraint
  dens <-
    sapply(rate, function(b) {
      dgamma(x = y, shape = 1 / 2, rate = 1 / (2 * b))
    }) %*%
    diag(prob) %>% 
    rowSums()
  -sum(log(dens))
}
```

```{r}
init_lam <- 
  sample(
    c(.6, .25, .15),
    size = 2000,
    replace = TRUE
  )
y <- rgamma(2000, shape = 1 / 2, rate =  1 / (2 * init_lam))
```

```{r}
opt <- optim(c(.3, .3, .5, .3), mix_ll, y = y)
```

```{r}
opt_df <- 
  broom::tidy(opt) %>% 
  spread(parameter, value)
#---------------------
colnames(opt_df) <- c("prob1", "prob2", "lambda1", "lambda2")
opt_df %>% 
  mutate(
    prob3 = 1 - prob1 - prob2,
    lambda3 = 1 - lambda1 - lambda2
  ) %>% 
  select(order(colnames(.)))
```


## EM Algorithm




